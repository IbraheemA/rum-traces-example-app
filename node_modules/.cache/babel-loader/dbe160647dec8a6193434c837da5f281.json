{"ast":null,"code":"'use strict';\n\nconst {\n  randomFillSync\n} = require('crypto');\nconst UINT_MAX = 4294967296;\nconst data = new Uint8Array(8 * 8192);\nconst zeroId = new Uint8Array(8);\nconst map = Array.prototype.map;\nconst pad = byte => `${byte < 16 ? '0' : ''}${byte.toString(16)}`;\nlet batch = 0;\n\n// Internal representation of a trace or span ID.\nclass Identifier {\n  constructor(value) {\n    let radix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;\n    this._isUint64BE = true; // msgpack-lite compatibility\n    this._buffer = radix === 16 ? createBuffer(value) : fromString(value, radix);\n  }\n  toString() {\n    let radix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 16;\n    return radix === 16 ? toHexString(this._buffer) : toNumberString(this._buffer, radix);\n  }\n  toBuffer() {\n    return this._buffer;\n  }\n\n  // msgpack-lite compatibility\n  toArray() {\n    if (this._buffer.length === 8) {\n      return this._buffer;\n    }\n    return this._buffer.slice(-8);\n  }\n  toJSON() {\n    return this.toString();\n  }\n  equals(other) {\n    const length = this._buffer.length;\n    const otherLength = other._buffer.length;\n\n    // Only compare the bytes available in both IDs.\n    for (let i = length, j = otherLength; i >= 0 && j >= 0; i--, j--) {\n      if (this._buffer[i] !== other._buffer[j]) return false;\n    }\n    return true;\n  }\n}\n\n// Create a buffer, using an optional hexadecimal value if provided.\nfunction createBuffer(value) {\n  if (value === '0') return zeroId;\n  if (!value) return pseudoRandom();\n  const size = Math.ceil(value.length / 16) * 16;\n  const bytes = size / 2;\n  const buffer = new Array(bytes);\n  value = value.padStart(size, '0');\n  for (let i = 0; i < bytes; i++) {\n    buffer[i] = parseInt(value.substring(i * 2, i * 2 + 2), 16);\n  }\n  return buffer;\n}\n\n// Convert a numerical string to a buffer using the specified radix.\nfunction fromString(str, raddix) {\n  const buffer = new Array(8);\n  const len = str.length;\n  let pos = 0;\n  let high = 0;\n  let low = 0;\n  if (str[0] === '-') pos++;\n  const sign = pos;\n  while (pos < len) {\n    const chr = parseInt(str[pos++], raddix);\n    if (!(chr >= 0)) break; // NaN\n\n    low = low * raddix + chr;\n    high = high * raddix + Math.floor(low / UINT_MAX);\n    low %= UINT_MAX;\n  }\n  if (sign) {\n    high = ~high;\n    if (low) {\n      low = UINT_MAX - low;\n    } else {\n      high++;\n    }\n  }\n  writeUInt32BE(buffer, high, 0);\n  writeUInt32BE(buffer, low, 4);\n  return buffer;\n}\n\n// Convert a buffer to a numerical string.\nfunction toNumberString(buffer, radix) {\n  let high = readInt32(buffer, buffer.length - 8);\n  let low = readInt32(buffer, buffer.length - 4);\n  let str = '';\n  radix = radix || 10;\n  while (1) {\n    const mod = high % radix * UINT_MAX + low;\n    high = Math.floor(high / radix);\n    low = Math.floor(mod / radix);\n    str = (mod % radix).toString(radix) + str;\n    if (!high && !low) break;\n  }\n  return str;\n}\n\n// Convert a buffer to a hexadecimal string.\nfunction toHexString(buffer) {\n  return map.call(buffer, pad).join('');\n}\n\n// Simple pseudo-random 64-bit ID generator.\nfunction pseudoRandom() {\n  if (batch === 0) {\n    randomFillSync(data);\n  }\n  batch = (batch + 1) % 8192;\n  const offset = batch * 8;\n  return [data[offset] & 0x7F,\n  // only positive int64,\n  data[offset + 1], data[offset + 2], data[offset + 3], data[offset + 4], data[offset + 5], data[offset + 6], data[offset + 7]];\n}\n\n// Read a buffer to unsigned integer bytes.\nfunction readInt32(buffer, offset) {\n  return buffer[offset + 0] * 16777216 + (buffer[offset + 1] << 16) + (buffer[offset + 2] << 8) + buffer[offset + 3];\n}\n\n// Write unsigned integer bytes to a buffer.\nfunction writeUInt32BE(buffer, value, offset) {\n  buffer[3 + offset] = value & 255;\n  value = value >> 8;\n  buffer[2 + offset] = value & 255;\n  value = value >> 8;\n  buffer[1 + offset] = value & 255;\n  value = value >> 8;\n  buffer[0 + offset] = value & 255;\n}\nmodule.exports = (value, radix) => new Identifier(value, radix);","map":{"version":3,"names":["randomFillSync","require","UINT_MAX","data","Uint8Array","zeroId","map","Array","prototype","pad","byte","toString","batch","Identifier","constructor","value","radix","arguments","length","undefined","_isUint64BE","_buffer","createBuffer","fromString","toHexString","toNumberString","toBuffer","toArray","slice","toJSON","equals","other","otherLength","i","j","pseudoRandom","size","Math","ceil","bytes","buffer","padStart","parseInt","substring","str","raddix","len","pos","high","low","sign","chr","floor","writeUInt32BE","readInt32","mod","call","join","offset","module","exports"],"sources":["/Users/ibraheem.aboulnaga/rum-traces-example-app/node_modules/dd-trace/packages/dd-trace/src/id.js"],"sourcesContent":["'use strict'\n\nconst { randomFillSync } = require('crypto')\n\nconst UINT_MAX = 4294967296\n\nconst data = new Uint8Array(8 * 8192)\nconst zeroId = new Uint8Array(8)\n\nconst map = Array.prototype.map\nconst pad = byte => `${byte < 16 ? '0' : ''}${byte.toString(16)}`\n\nlet batch = 0\n\n// Internal representation of a trace or span ID.\nclass Identifier {\n  constructor (value, radix = 16) {\n    this._isUint64BE = true // msgpack-lite compatibility\n    this._buffer = radix === 16\n      ? createBuffer(value)\n      : fromString(value, radix)\n  }\n\n  toString (radix = 16) {\n    return radix === 16\n      ? toHexString(this._buffer)\n      : toNumberString(this._buffer, radix)\n  }\n\n  toBuffer () {\n    return this._buffer\n  }\n\n  // msgpack-lite compatibility\n  toArray () {\n    if (this._buffer.length === 8) {\n      return this._buffer\n    }\n    return this._buffer.slice(-8)\n  }\n\n  toJSON () {\n    return this.toString()\n  }\n\n  equals (other) {\n    const length = this._buffer.length\n    const otherLength = other._buffer.length\n\n    // Only compare the bytes available in both IDs.\n    for (let i = length, j = otherLength; i >= 0 && j >= 0; i--, j--) {\n      if (this._buffer[i] !== other._buffer[j]) return false\n    }\n\n    return true\n  }\n}\n\n// Create a buffer, using an optional hexadecimal value if provided.\nfunction createBuffer (value) {\n  if (value === '0') return zeroId\n  if (!value) return pseudoRandom()\n\n  const size = Math.ceil(value.length / 16) * 16\n  const bytes = size / 2\n  const buffer = new Array(bytes)\n\n  value = value.padStart(size, '0')\n\n  for (let i = 0; i < bytes; i++) {\n    buffer[i] = parseInt(value.substring(i * 2, i * 2 + 2), 16)\n  }\n\n  return buffer\n}\n\n// Convert a numerical string to a buffer using the specified radix.\nfunction fromString (str, raddix) {\n  const buffer = new Array(8)\n  const len = str.length\n\n  let pos = 0\n  let high = 0\n  let low = 0\n\n  if (str[0] === '-') pos++\n\n  const sign = pos\n\n  while (pos < len) {\n    const chr = parseInt(str[pos++], raddix)\n\n    if (!(chr >= 0)) break // NaN\n\n    low = low * raddix + chr\n    high = high * raddix + Math.floor(low / UINT_MAX)\n    low %= UINT_MAX\n  }\n\n  if (sign) {\n    high = ~high\n\n    if (low) {\n      low = UINT_MAX - low\n    } else {\n      high++\n    }\n  }\n\n  writeUInt32BE(buffer, high, 0)\n  writeUInt32BE(buffer, low, 4)\n\n  return buffer\n}\n\n// Convert a buffer to a numerical string.\nfunction toNumberString (buffer, radix) {\n  let high = readInt32(buffer, buffer.length - 8)\n  let low = readInt32(buffer, buffer.length - 4)\n  let str = ''\n\n  radix = radix || 10\n\n  while (1) {\n    const mod = (high % radix) * UINT_MAX + low\n\n    high = Math.floor(high / radix)\n    low = Math.floor(mod / radix)\n    str = (mod % radix).toString(radix) + str\n\n    if (!high && !low) break\n  }\n\n  return str\n}\n\n// Convert a buffer to a hexadecimal string.\nfunction toHexString (buffer) {\n  return map.call(buffer, pad).join('')\n}\n\n// Simple pseudo-random 64-bit ID generator.\nfunction pseudoRandom () {\n  if (batch === 0) {\n    randomFillSync(data)\n  }\n\n  batch = (batch + 1) % 8192\n\n  const offset = batch * 8\n\n  return [\n    data[offset] & 0x7F, // only positive int64,\n    data[offset + 1],\n    data[offset + 2],\n    data[offset + 3],\n    data[offset + 4],\n    data[offset + 5],\n    data[offset + 6],\n    data[offset + 7]\n  ]\n}\n\n// Read a buffer to unsigned integer bytes.\nfunction readInt32 (buffer, offset) {\n  return (buffer[offset + 0] * 16777216) +\n    (buffer[offset + 1] << 16) +\n    (buffer[offset + 2] << 8) +\n    buffer[offset + 3]\n}\n\n// Write unsigned integer bytes to a buffer.\nfunction writeUInt32BE (buffer, value, offset) {\n  buffer[3 + offset] = value & 255\n  value = value >> 8\n  buffer[2 + offset] = value & 255\n  value = value >> 8\n  buffer[1 + offset] = value & 255\n  value = value >> 8\n  buffer[0 + offset] = value & 255\n}\n\nmodule.exports = (value, radix) => new Identifier(value, radix)\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}