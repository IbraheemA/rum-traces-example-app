{"ast":null,"code":"'use strict';\n\nconst crypto = require('crypto');\nconst path = require('path');\nfunction isTrue(str) {\n  str = String(str).toLowerCase();\n  return str === 'true' || str === '1';\n}\nfunction isFalse(str) {\n  str = String(str).toLowerCase();\n  return str === 'false' || str === '0';\n}\nfunction isError(value) {\n  if (value instanceof Error) {\n    return true;\n  }\n  if (value && value.message) {\n    return true;\n  }\n  return false;\n}\n\n// Matches a glob pattern to a given subject string\nfunction globMatch(pattern, subject) {\n  let px = 0; // [p]attern inde[x]\n  let sx = 0; // [s]ubject inde[x]\n  let nextPx = 0;\n  let nextSx = 0;\n  while (px < pattern.length || sx < subject.length) {\n    if (px < pattern.length) {\n      const c = pattern[px];\n      switch (c) {\n        case '?':\n          if (sx < subject.length) {\n            px++;\n            sx++;\n            continue;\n          }\n          break;\n        case '*':\n          nextPx = px;\n          nextSx = sx + 1;\n          px++;\n          continue;\n        default:\n          // ordinary character\n          if (sx < subject.length && subject[sx] === c) {\n            px++;\n            sx++;\n            continue;\n          }\n          break;\n      }\n    }\n    if (nextSx > 0 && nextSx <= subject.length) {\n      px = nextPx;\n      sx = nextSx;\n      continue;\n    }\n    return false;\n  }\n  return true;\n}\nfunction calculateDDBasePath(dirname) {\n  const dirSteps = dirname.split(path.sep);\n  const packagesIndex = dirSteps.lastIndexOf('packages');\n  return dirSteps.slice(0, packagesIndex + 1).join(path.sep) + path.sep;\n}\nfunction hasOwn(object, prop) {\n  return Object.prototype.hasOwnProperty.call(object, prop);\n}\n\n/**\n * Generates a unique hash from an array of strings by joining them with | before hashing.\n * Used to uniquely identify AWS requests for span pointers.\n * @param {string[]} components - Array of strings to hash\n * @returns {string} A 32-character hash uniquely identifying the components\n */\nfunction generatePointerHash(components) {\n  // If passing S3's ETag as a component, make sure any quotes have already been removed!\n  const dataToHash = components.join('|');\n  const hash = crypto.createHash('sha256').update(dataToHash).digest('hex');\n  return hash.substring(0, 32);\n}\nmodule.exports = {\n  isTrue,\n  isFalse,\n  isError,\n  globMatch,\n  calculateDDBasePath,\n  hasOwn,\n  generatePointerHash\n};","map":{"version":3,"names":["crypto","require","path","isTrue","str","String","toLowerCase","isFalse","isError","value","Error","message","globMatch","pattern","subject","px","sx","nextPx","nextSx","length","c","calculateDDBasePath","dirname","dirSteps","split","sep","packagesIndex","lastIndexOf","slice","join","hasOwn","object","prop","Object","prototype","hasOwnProperty","call","generatePointerHash","components","dataToHash","hash","createHash","update","digest","substring","module","exports"],"sources":["/Users/ibraheem.aboulnaga/rum-traces-example-app/node_modules/dd-trace/packages/dd-trace/src/util.js"],"sourcesContent":["'use strict'\n\nconst crypto = require('crypto')\nconst path = require('path')\n\nfunction isTrue (str) {\n  str = String(str).toLowerCase()\n  return str === 'true' || str === '1'\n}\n\nfunction isFalse (str) {\n  str = String(str).toLowerCase()\n  return str === 'false' || str === '0'\n}\n\nfunction isError (value) {\n  if (value instanceof Error) {\n    return true\n  }\n  if (value && value.message) {\n    return true\n  }\n  return false\n}\n\n// Matches a glob pattern to a given subject string\nfunction globMatch (pattern, subject) {\n  let px = 0 // [p]attern inde[x]\n  let sx = 0 // [s]ubject inde[x]\n  let nextPx = 0\n  let nextSx = 0\n  while (px < pattern.length || sx < subject.length) {\n    if (px < pattern.length) {\n      const c = pattern[px]\n      switch (c) {\n        case '?':\n          if (sx < subject.length) {\n            px++\n            sx++\n            continue\n          }\n          break\n        case '*':\n          nextPx = px\n          nextSx = sx + 1\n          px++\n          continue\n        default: // ordinary character\n          if (sx < subject.length && subject[sx] === c) {\n            px++\n            sx++\n            continue\n          }\n          break\n      }\n    }\n    if (nextSx > 0 && nextSx <= subject.length) {\n      px = nextPx\n      sx = nextSx\n      continue\n    }\n    return false\n  }\n  return true\n}\n\nfunction calculateDDBasePath (dirname) {\n  const dirSteps = dirname.split(path.sep)\n  const packagesIndex = dirSteps.lastIndexOf('packages')\n  return dirSteps.slice(0, packagesIndex + 1).join(path.sep) + path.sep\n}\n\nfunction hasOwn (object, prop) {\n  return Object.prototype.hasOwnProperty.call(object, prop)\n}\n\n/**\n * Generates a unique hash from an array of strings by joining them with | before hashing.\n * Used to uniquely identify AWS requests for span pointers.\n * @param {string[]} components - Array of strings to hash\n * @returns {string} A 32-character hash uniquely identifying the components\n */\nfunction generatePointerHash (components) {\n  // If passing S3's ETag as a component, make sure any quotes have already been removed!\n  const dataToHash = components.join('|')\n  const hash = crypto.createHash('sha256').update(dataToHash).digest('hex')\n  return hash.substring(0, 32)\n}\n\nmodule.exports = {\n  isTrue,\n  isFalse,\n  isError,\n  globMatch,\n  calculateDDBasePath,\n  hasOwn,\n  generatePointerHash\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}