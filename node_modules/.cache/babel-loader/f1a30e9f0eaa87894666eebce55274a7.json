{"ast":null,"code":"'use strict';\n\nconst api = require('@opentelemetry/api');\nconst {\n  sanitizeAttributes\n} = require('@opentelemetry/core');\nconst Sampler = require('./sampler');\nconst Span = require('./span');\nconst id = require('../id');\nconst SpanContext = require('./span_context');\nconst TextMapPropagator = require('../opentracing/propagation/text_map');\nclass Tracer {\n  constructor(library, config, tracerProvider) {\n    this._sampler = new Sampler();\n    this._config = config;\n    this._tracerProvider = tracerProvider;\n    // Is there a reason this is public?\n    this.instrumentationLibrary = library;\n    this._isOtelLibrary = library?.name?.startsWith('@opentelemetry/instrumentation-');\n    this._spanLimits = {};\n  }\n  get resource() {\n    return this._tracerProvider.resource;\n  }\n  _createSpanContextFromParent(parentSpanContext) {\n    return new SpanContext({\n      traceId: parentSpanContext._traceId,\n      spanId: id(),\n      parentId: parentSpanContext._spanId,\n      sampling: parentSpanContext._sampling,\n      baggageItems: Object.assign({}, parentSpanContext._baggageItems),\n      trace: parentSpanContext._trace,\n      tracestate: parentSpanContext._tracestate\n    });\n  }\n\n  // Extracted method to create span context for a new span\n  _createSpanContextForNewSpan(context) {\n    const {\n      traceId,\n      spanId,\n      traceFlags,\n      traceState\n    } = context;\n    return TextMapPropagator._convertOtelContextToDatadog(traceId, spanId, traceFlags, traceState);\n  }\n  startSpan(name) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : api.context.active();\n    // remove span from context in case a root span is requested via options\n    if (options.root) {\n      context = api.trace.deleteSpan(context);\n    }\n    const parentSpan = api.trace.getSpan(context);\n    const parentSpanContext = parentSpan && parentSpan.spanContext();\n    let spanContext;\n    if (parentSpanContext && api.trace.isSpanContextValid(parentSpanContext)) {\n      spanContext = parentSpanContext._ddContext ? this._createSpanContextFromParent(parentSpanContext._ddContext) : this._createSpanContextForNewSpan(parentSpanContext);\n    } else {\n      spanContext = new SpanContext();\n    }\n    const spanKind = options.kind || api.SpanKind.INTERNAL;\n    const links = (options.links || []).map(link => {\n      return {\n        context: link.context,\n        attributes: sanitizeAttributes(link.attributes)\n      };\n    });\n    const attributes = sanitizeAttributes(options.attributes);\n\n    // TODO: sampling API is not yet supported\n    // // make sampling decision\n    // const samplingResult = this._sampler.shouldSample(\n    //   context,\n    //   spanContext.traceId,\n    //   name,\n    //   spanKind,\n    //   attributes,\n    //   links\n    // )\n\n    // // Should use new span context\n    // spanContext._ddContext._sampling.priority =\n    //   samplingResult.decision === api.SamplingDecision.RECORD_AND_SAMPLED\n    //     ? AUTO_KEEP\n    //     : AUTO_REJECT\n\n    // if (samplingResult.decision === api.SamplingDecision.NOT_RECORD) {\n    //   api.diag.debug('Recording is off, propagating context in a non-recording span')\n    //   return api.trace.wrapSpanContext(spanContext)\n    // }\n\n    return new Span(this, context, name, spanContext, spanKind, links, options.startTime,\n    // Set initial span attributes. The attributes object may have been mutated\n    // by the sampler, so we sanitize the merged attributes before setting them.\n    sanitizeAttributes(\n    // Object.assign(attributes, samplingResult.attributes)\n    attributes));\n  }\n  startActiveSpan(name, options, context, fn) {\n    if (arguments.length === 2) {\n      fn = options;\n      context = undefined;\n      options = undefined;\n    } else if (arguments.length === 3) {\n      fn = context;\n      context = undefined;\n    } else if (arguments.length !== 4) {\n      return;\n    }\n    const parentContext = context || api.context.active();\n    const span = this.startSpan(name, options, parentContext);\n    const contextWithSpanSet = api.trace.setSpan(parentContext, span);\n    return api.context.with(contextWithSpanSet, fn, undefined, span);\n  }\n  getActiveSpanProcessor() {\n    return this._tracerProvider.getActiveSpanProcessor();\n  }\n\n  // not used in our codebase but needed for compatibility. See issue #1244\n  getSpanLimits() {\n    return this._spanLimits;\n  }\n}\nmodule.exports = Tracer;","map":{"version":3,"names":["api","require","sanitizeAttributes","Sampler","Span","id","SpanContext","TextMapPropagator","Tracer","constructor","library","config","tracerProvider","_sampler","_config","_tracerProvider","instrumentationLibrary","_isOtelLibrary","name","startsWith","_spanLimits","resource","_createSpanContextFromParent","parentSpanContext","traceId","_traceId","spanId","parentId","_spanId","sampling","_sampling","baggageItems","Object","assign","_baggageItems","trace","_trace","tracestate","_tracestate","_createSpanContextForNewSpan","context","traceFlags","traceState","_convertOtelContextToDatadog","startSpan","options","arguments","length","undefined","active","root","deleteSpan","parentSpan","getSpan","spanContext","isSpanContextValid","_ddContext","spanKind","kind","SpanKind","INTERNAL","links","map","link","attributes","startTime","startActiveSpan","fn","parentContext","span","contextWithSpanSet","setSpan","with","getActiveSpanProcessor","getSpanLimits","module","exports"],"sources":["/Users/ibraheem.aboulnaga/rum-traces-example-app/node_modules/dd-trace/packages/dd-trace/src/opentelemetry/tracer.js"],"sourcesContent":["'use strict'\n\nconst api = require('@opentelemetry/api')\nconst { sanitizeAttributes } = require('@opentelemetry/core')\n\nconst Sampler = require('./sampler')\nconst Span = require('./span')\nconst id = require('../id')\nconst SpanContext = require('./span_context')\nconst TextMapPropagator = require('../opentracing/propagation/text_map')\n\nclass Tracer {\n  constructor (library, config, tracerProvider) {\n    this._sampler = new Sampler()\n    this._config = config\n    this._tracerProvider = tracerProvider\n    // Is there a reason this is public?\n    this.instrumentationLibrary = library\n    this._isOtelLibrary = library?.name?.startsWith('@opentelemetry/instrumentation-')\n    this._spanLimits = {}\n  }\n\n  get resource () {\n    return this._tracerProvider.resource\n  }\n\n  _createSpanContextFromParent (parentSpanContext) {\n    return new SpanContext({\n      traceId: parentSpanContext._traceId,\n      spanId: id(),\n      parentId: parentSpanContext._spanId,\n      sampling: parentSpanContext._sampling,\n      baggageItems: Object.assign({}, parentSpanContext._baggageItems),\n      trace: parentSpanContext._trace,\n      tracestate: parentSpanContext._tracestate\n    })\n  }\n\n  // Extracted method to create span context for a new span\n  _createSpanContextForNewSpan (context) {\n    const { traceId, spanId, traceFlags, traceState } = context\n    return TextMapPropagator._convertOtelContextToDatadog(traceId, spanId, traceFlags, traceState)\n  }\n\n  startSpan (name, options = {}, context = api.context.active()) {\n    // remove span from context in case a root span is requested via options\n    if (options.root) {\n      context = api.trace.deleteSpan(context)\n    }\n    const parentSpan = api.trace.getSpan(context)\n    const parentSpanContext = parentSpan && parentSpan.spanContext()\n    let spanContext\n    if (parentSpanContext && api.trace.isSpanContextValid(parentSpanContext)) {\n      spanContext = parentSpanContext._ddContext\n        ? this._createSpanContextFromParent(parentSpanContext._ddContext)\n        : this._createSpanContextForNewSpan(parentSpanContext)\n    } else {\n      spanContext = new SpanContext()\n    }\n\n    const spanKind = options.kind || api.SpanKind.INTERNAL\n    const links = (options.links || []).map(link => {\n      return {\n        context: link.context,\n        attributes: sanitizeAttributes(link.attributes)\n      }\n    })\n    const attributes = sanitizeAttributes(options.attributes)\n\n    // TODO: sampling API is not yet supported\n    // // make sampling decision\n    // const samplingResult = this._sampler.shouldSample(\n    //   context,\n    //   spanContext.traceId,\n    //   name,\n    //   spanKind,\n    //   attributes,\n    //   links\n    // )\n\n    // // Should use new span context\n    // spanContext._ddContext._sampling.priority =\n    //   samplingResult.decision === api.SamplingDecision.RECORD_AND_SAMPLED\n    //     ? AUTO_KEEP\n    //     : AUTO_REJECT\n\n    // if (samplingResult.decision === api.SamplingDecision.NOT_RECORD) {\n    //   api.diag.debug('Recording is off, propagating context in a non-recording span')\n    //   return api.trace.wrapSpanContext(spanContext)\n    // }\n\n    return new Span(\n      this,\n      context,\n      name,\n      spanContext,\n      spanKind,\n      links,\n      options.startTime,\n\n      // Set initial span attributes. The attributes object may have been mutated\n      // by the sampler, so we sanitize the merged attributes before setting them.\n      sanitizeAttributes(\n        // Object.assign(attributes, samplingResult.attributes)\n        attributes\n      )\n    )\n  }\n\n  startActiveSpan (name, options, context, fn) {\n    if (arguments.length === 2) {\n      fn = options\n      context = undefined\n      options = undefined\n    } else if (arguments.length === 3) {\n      fn = context\n      context = undefined\n    } else if (arguments.length !== 4) {\n      return\n    }\n\n    const parentContext = context || api.context.active()\n    const span = this.startSpan(name, options, parentContext)\n    const contextWithSpanSet = api.trace.setSpan(parentContext, span)\n\n    return api.context.with(contextWithSpanSet, fn, undefined, span)\n  }\n\n  getActiveSpanProcessor () {\n    return this._tracerProvider.getActiveSpanProcessor()\n  }\n\n  // not used in our codebase but needed for compatibility. See issue #1244\n  getSpanLimits () {\n    return this._spanLimits\n  }\n}\n\nmodule.exports = Tracer\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}